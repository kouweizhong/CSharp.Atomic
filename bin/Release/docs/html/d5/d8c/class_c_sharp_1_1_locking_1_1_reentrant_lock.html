<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CSharp.Atomic: Concurrent Data Structures: CSharp.Locking.ReentrantLock Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CSharp.Atomic: Concurrent Data Structures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CSharp.Locking.ReentrantLock Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CSharp::Locking::ReentrantLock" --><!-- doxytag: inherits="CSharp::Locking::ILock" -->
<p>A reentrant mutual exclusion <code><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation.">ILock</a></code> with the same basic behavior and semantics as the implicit monitor lock accessed using the <code>lock</code> keyword, but with some additional capabilities.  
 <a href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for CSharp.Locking.ReentrantLock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.png" usemap="#CSharp.Locking.ReentrantLock_map" alt=""/>
  <map id="CSharp.Locking.ReentrantLock_map" name="CSharp.Locking.ReentrantLock_map">
<area href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation." alt="CSharp.Locking.ILock" shape="rect" coords="0,0,188,24"/>
</map>
 </div></div>

<p><a href="../../dd/d6a/class_c_sharp_1_1_locking_1_1_reentrant_lock-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#abce89d22c5b20fb88ce7fb9aae764151">ReentrantLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">CSharp.Locking.ReentrantLock</a> class.  <a href="#abce89d22c5b20fb88ce7fb9aae764151"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a91f22799ce44076c4020b99d58a9e69f">Lock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the the current instance,.  <a href="#a91f22799ce44076c4020b99d58a9e69f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a342971b63653ef108c79bf6eabb6eab0">TryLock</a> (int timeoutMs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeoutMs</code> specified.  <a href="#a342971b63653ef108c79bf6eabb6eab0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#aba82c7888e0c93a7120348bc6a5a59f3">TryLock</a> (TimeSpan timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeout</code> specified.  <a href="#aba82c7888e0c93a7120348bc6a5a59f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html">ICondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a1195aef8c1e13dee9183add1cf2d5e53">NewCondition</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code><a class="el" href="../../de/d03/class_c_sharp_1_1_locking_1_1_lock_condition.html" title="The default ICondition implementation for use with CSharp.Locking.ReentrantLock.">LockCondition</a></code> implementation for use with the current lock.  <a href="#a1195aef8c1e13dee9183add1cf2d5e53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a7b89063f6f7d6e5befcffd0ff42ac9bc">Unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <a href="#a7b89063f6f7d6e5befcffd0ff42ac9bc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#aa17e00a851666c8082a4b267cb9ebb60">IsHeldByCurrentThread</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whther or not the current thread is holding the lock or not.  <a href="#aa17e00a851666c8082a4b267cb9ebb60"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A reentrant mutual exclusion <code><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation.">ILock</a></code> with the same basic behavior and semantics as the implicit monitor lock accessed using the <code>lock</code> keyword, but with some additional capabilities. </p>
<p>A <code><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">ReentrantLock</a></code> is owned by the thread last successfully locking, but not yet unlocking it. A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock. This can be checked using the property <code>IsHeldByCurrentThread</code> </p>
<p>This class does not currently support fairness like the java version of this lock, <code>java.util.concurrent.locks.ReentrantLock</code></p>
<p>&lt;author&gt;Matt Bolt&lt;/author&gt; </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abce89d22c5b20fb88ce7fb9aae764151"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::ReentrantLock" ref="abce89d22c5b20fb88ce7fb9aae764151" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSharp.Locking.ReentrantLock.ReentrantLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">CSharp.Locking.ReentrantLock</a> class. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a91f22799ce44076c4020b99d58a9e69f"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::Lock" ref="a91f22799ce44076c4020b99d58a9e69f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSharp.Locking.ReentrantLock.Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the the current instance,. </p>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a19bec6e61fbc2bc3681a9a49094c7792">CSharp.Locking.ILock</a>.</p>

</div>
</div>
<a class="anchor" id="a1195aef8c1e13dee9183add1cf2d5e53"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::NewCondition" ref="a1195aef8c1e13dee9183add1cf2d5e53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html">ICondition</a> CSharp.Locking.ReentrantLock.NewCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new <code><a class="el" href="../../de/d03/class_c_sharp_1_1_locking_1_1_lock_condition.html" title="The default ICondition implementation for use with CSharp.Locking.ReentrantLock.">LockCondition</a></code> implementation for use with the current lock. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new condition instance used for flow control within a lock.</dd></dl>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a020b1078ec37709bdc9e770de0fea9a1">CSharp.Locking.ILock</a>.</p>

</div>
</div>
<a class="anchor" id="a342971b63653ef108c79bf6eabb6eab0"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::TryLock" ref="a342971b63653ef108c79bf6eabb6eab0" args="(int timeoutMs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.TryLock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeoutMs</code> specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutMs</td><td>The maximum time to wait before failing, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the thread obtains the lock, or <code>false</code> if the timeout occurs before successfully obtaining the lock. </dd></dl>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a503ae784a669a0312b99517e38c3e428">CSharp.Locking.ILock</a>.</p>

</div>
</div>
<a class="anchor" id="aba82c7888e0c93a7120348bc6a5a59f3"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::TryLock" ref="aba82c7888e0c93a7120348bc6a5a59f3" args="(TimeSpan timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.TryLock </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeout</code> specified. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum time to wait before failing..</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the thread obtains the lock, or <code>false</code> if the timeout occurs before successfully obtaining the lock. </dd></dl>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a7126725440b0f48677ba523a2c6ef038">CSharp.Locking.ILock</a>.</p>

</div>
</div>
<a class="anchor" id="a7b89063f6f7d6e5befcffd0ff42ac9bc"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::Unlock" ref="a7b89063f6f7d6e5befcffd0ff42ac9bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSharp.Locking.ReentrantLock.Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Releases the lock. </p>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#aa14877fb0d528277d68b1de9322a52a8">CSharp.Locking.ILock</a>.</p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="aa17e00a851666c8082a4b267cb9ebb60"></a><!-- doxytag: member="CSharp::Locking::ReentrantLock::IsHeldByCurrentThread" ref="aa17e00a851666c8082a4b267cb9ebb60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.IsHeldByCurrentThread<code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Whther or not the current thread is holding the lock or not. </p>
<p><code>true</code> if the current thread is holding the lock; otherwise, <code>false</code></p>

<p>Implements <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#ab7d725ea743b321e2ddef2033cb27324">CSharp.Locking.ILock</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d4/d9e/namespace_c_sharp.html">CSharp</a>      </li>
      <li class="navelem"><a class="el" href="../../d4/d70/namespace_c_sharp_1_1_locking.html">Locking</a>      </li>
      <li class="navelem"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html">ReentrantLock</a>      </li>
      <li class="footer">Generated on Thu May 2 2013 19:03:47 for CSharp.Atomic: Concurrent Data Structures by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
