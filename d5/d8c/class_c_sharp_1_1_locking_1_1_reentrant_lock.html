<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CSharp.Atomic: Concurrent Data Structures: CSharp.Locking.ReentrantLock Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CSharp.Atomic: Concurrent Data Structures
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="../../dd/d6a/class_c_sharp_1_1_locking_1_1_reentrant_lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CSharp.Locking.ReentrantLock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A reentrant mutual exclusion <code><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation.">ILock</a></code> with the same basic behavior and semantics as the implicit monitor lock accessed using the <code>lock</code> keyword, but with some additional capabilities.  
 <a href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for CSharp.Locking.ReentrantLock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.png" usemap="#CSharp.Locking.ReentrantLock_map" alt=""/>
  <map id="CSharp.Locking.ReentrantLock_map" name="CSharp.Locking.ReentrantLock_map">
<area href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation." alt="CSharp.Locking.ILock" shape="rect" coords="0,0,188,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abce89d22c5b20fb88ce7fb9aae764151"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#abce89d22c5b20fb88ce7fb9aae764151">ReentrantLock</a> ()</td></tr>
<tr class="memdesc:abce89d22c5b20fb88ce7fb9aae764151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new instance of the <a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">CSharp.Locking.ReentrantLock</a> class.  <a href="#abce89d22c5b20fb88ce7fb9aae764151"></a><br/></td></tr>
<tr class="separator:abce89d22c5b20fb88ce7fb9aae764151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f22799ce44076c4020b99d58a9e69f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a91f22799ce44076c4020b99d58a9e69f">Lock</a> ()</td></tr>
<tr class="memdesc:a91f22799ce44076c4020b99d58a9e69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the the current instance,  <a href="#a91f22799ce44076c4020b99d58a9e69f"></a><br/></td></tr>
<tr class="separator:a91f22799ce44076c4020b99d58a9e69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342971b63653ef108c79bf6eabb6eab0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a342971b63653ef108c79bf6eabb6eab0">TryLock</a> (int timeoutMs)</td></tr>
<tr class="memdesc:a342971b63653ef108c79bf6eabb6eab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeoutMs</code> specified.  <a href="#a342971b63653ef108c79bf6eabb6eab0"></a><br/></td></tr>
<tr class="separator:a342971b63653ef108c79bf6eabb6eab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba82c7888e0c93a7120348bc6a5a59f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#aba82c7888e0c93a7120348bc6a5a59f3">TryLock</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:aba82c7888e0c93a7120348bc6a5a59f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeout</code> specified.  <a href="#aba82c7888e0c93a7120348bc6a5a59f3"></a><br/></td></tr>
<tr class="separator:aba82c7888e0c93a7120348bc6a5a59f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1195aef8c1e13dee9183add1cf2d5e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html">ICondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a1195aef8c1e13dee9183add1cf2d5e53">NewCondition</a> ()</td></tr>
<tr class="memdesc:a1195aef8c1e13dee9183add1cf2d5e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <code><a class="el" href="../../de/d03/class_c_sharp_1_1_locking_1_1_lock_condition.html" title="The default ICondition implementation for use with CSharp.Locking.ReentrantLock.">LockCondition</a></code> implementation for use with the current lock.  <a href="#a1195aef8c1e13dee9183add1cf2d5e53"></a><br/></td></tr>
<tr class="separator:a1195aef8c1e13dee9183add1cf2d5e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b89063f6f7d6e5befcffd0ff42ac9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#a7b89063f6f7d6e5befcffd0ff42ac9bc">Unlock</a> ()</td></tr>
<tr class="memdesc:a7b89063f6f7d6e5befcffd0ff42ac9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <a href="#a7b89063f6f7d6e5befcffd0ff42ac9bc"></a><br/></td></tr>
<tr class="separator:a7b89063f6f7d6e5befcffd0ff42ac9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html">CSharp.Locking.ILock</a></td></tr>
<tr class="memitem:a19bec6e61fbc2bc3681a9a49094c7792 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a19bec6e61fbc2bc3681a9a49094c7792">Lock</a> ()</td></tr>
<tr class="memdesc:a19bec6e61fbc2bc3681a9a49094c7792 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock if it is available.  <a href="#a19bec6e61fbc2bc3681a9a49094c7792"></a><br/></td></tr>
<tr class="separator:a19bec6e61fbc2bc3681a9a49094c7792 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ae784a669a0312b99517e38c3e428 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a503ae784a669a0312b99517e38c3e428">TryLock</a> (int timeoutMs)</td></tr>
<tr class="memdesc:a503ae784a669a0312b99517e38c3e428 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock, given a timeout in milliseconds.  <a href="#a503ae784a669a0312b99517e38c3e428"></a><br/></td></tr>
<tr class="separator:a503ae784a669a0312b99517e38c3e428 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7126725440b0f48677ba523a2c6ef038 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a7126725440b0f48677ba523a2c6ef038">TryLock</a> (TimeSpan timeout)</td></tr>
<tr class="memdesc:a7126725440b0f48677ba523a2c6ef038 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock, given a timeout as a <code>TimeSpan</code>.  <a href="#a7126725440b0f48677ba523a2c6ef038"></a><br/></td></tr>
<tr class="separator:a7126725440b0f48677ba523a2c6ef038 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14877fb0d528277d68b1de9322a52a8 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#aa14877fb0d528277d68b1de9322a52a8">Unlock</a> ()</td></tr>
<tr class="memdesc:aa14877fb0d528277d68b1de9322a52a8 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <a href="#aa14877fb0d528277d68b1de9322a52a8"></a><br/></td></tr>
<tr class="separator:aa14877fb0d528277d68b1de9322a52a8 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b1078ec37709bdc9e770de0fea9a1 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html">ICondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#a020b1078ec37709bdc9e770de0fea9a1">NewCondition</a> ()</td></tr>
<tr class="memdesc:a020b1078ec37709bdc9e770de0fea9a1 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html" title="This interface defines a condition instance that can be used for flow control within a lock...">ICondition</a></code> instance for use with this <code><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation.">ILock</a></code> instance.  <a href="#a020b1078ec37709bdc9e770de0fea9a1"></a><br/></td></tr>
<tr class="separator:a020b1078ec37709bdc9e770de0fea9a1 inherit pub_methods_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:aa17e00a851666c8082a4b267cb9ebb60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html#aa17e00a851666c8082a4b267cb9ebb60">IsHeldByCurrentThread</a><code> [get]</code></td></tr>
<tr class="memdesc:aa17e00a851666c8082a4b267cb9ebb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whther or not the current thread is holding the lock or not.  <a href="#aa17e00a851666c8082a4b267cb9ebb60"></a><br/></td></tr>
<tr class="separator:aa17e00a851666c8082a4b267cb9ebb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_interface_c_sharp_1_1_locking_1_1_i_lock"><td colspan="2" onclick="javascript:toggleInherit('properties_interface_c_sharp_1_1_locking_1_1_i_lock')"><img src="../../closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html">CSharp.Locking.ILock</a></td></tr>
<tr class="memitem:ab7d725ea743b321e2ddef2033cb27324 inherit properties_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html#ab7d725ea743b321e2ddef2033cb27324">IsHeldByCurrentThread</a><code> [get]</code></td></tr>
<tr class="memdesc:ab7d725ea743b321e2ddef2033cb27324 inherit properties_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value indicating whether the current thread is the lock holder.  <a href="#ab7d725ea743b321e2ddef2033cb27324"></a><br/></td></tr>
<tr class="separator:ab7d725ea743b321e2ddef2033cb27324 inherit properties_interface_c_sharp_1_1_locking_1_1_i_lock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A reentrant mutual exclusion <code><a class="el" href="../../d8/d01/interface_c_sharp_1_1_locking_1_1_i_lock.html" title="This interface represents a thread access locking implementation.">ILock</a></code> with the same basic behavior and semantics as the implicit monitor lock accessed using the <code>lock</code> keyword, but with some additional capabilities. </p>
<p>A <code><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">ReentrantLock</a></code> is owned by the thread last successfully locking, but not yet unlocking it. A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock. This can be checked using the property <code>IsHeldByCurrentThread</code> </p>
<p>This class does not currently support fairness like the java version of this lock, <code>java.util.concurrent.locks.ReentrantLock</code> </p>
<p>&lt;author&gt;Matt Bolt&lt;/author&gt; </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abce89d22c5b20fb88ce7fb9aae764151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSharp.Locking.ReentrantLock.ReentrantLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new instance of the <a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html" title="A reentrant mutual exclusion ILock with the same basic behavior and semantics as the implicit monitor...">CSharp.Locking.ReentrantLock</a> class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a91f22799ce44076c4020b99d58a9e69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSharp.Locking.ReentrantLock.Lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the the current instance, </p>

</div>
</div>
<a class="anchor" id="a1195aef8c1e13dee9183add1cf2d5e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d75/interface_c_sharp_1_1_locking_1_1_i_condition.html">ICondition</a> CSharp.Locking.ReentrantLock.NewCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <code><a class="el" href="../../de/d03/class_c_sharp_1_1_locking_1_1_lock_condition.html" title="The default ICondition implementation for use with CSharp.Locking.ReentrantLock.">LockCondition</a></code> implementation for use with the current lock. </p>
<dl class="section return"><dt>Returns</dt><dd>A new condition instance used for flow control within a lock.</dd></dl>

</div>
</div>
<a class="anchor" id="a342971b63653ef108c79bf6eabb6eab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.TryLock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeoutMs</code> specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutMs</td><td>The maximum time to wait before failing, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread obtains the lock, or <code>false</code> if the timeout occurs before successfully obtaining the lock. </dd></dl>

</div>
</div>
<a class="anchor" id="aba82c7888e0c93a7120348bc6a5a59f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.TryLock </td>
          <td>(</td>
          <td class="paramtype">TimeSpan&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to obtain the lock for this instance, at most, waiting the length of the <code>timeout</code> specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum time to wait before failing..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread obtains the lock, or <code>false</code> if the timeout occurs before successfully obtaining the lock. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b89063f6f7d6e5befcffd0ff42ac9bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSharp.Locking.ReentrantLock.Unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock. </p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a class="anchor" id="aa17e00a851666c8082a4b267cb9ebb60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CSharp.Locking.ReentrantLock.IsHeldByCurrentThread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whther or not the current thread is holding the lock or not. </p>
<p><code>true</code> if the current thread is holding the lock; otherwise, <code>false</code></p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d4/d9e/namespace_c_sharp.html">CSharp</a></li><li class="navelem"><a class="el" href="../../d4/d70/namespace_c_sharp_1_1_locking.html">Locking</a></li><li class="navelem"><a class="el" href="../../d5/d8c/class_c_sharp_1_1_locking_1_1_reentrant_lock.html">ReentrantLock</a></li>
    <li class="footer">Generated on Thu May 2 2013 21:35:06 for CSharp.Atomic: Concurrent Data Structures by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
